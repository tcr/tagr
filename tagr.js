// Generated by CoffeeScript 1.3.1

/*

Tagr, HTML manipulation for webapps.

TODO
smaller syntax for manipulation
*/


(function() {
  var DomMap, EventEmitter, Script, Stylesheet, Tagr, TagrList, addDomReadyListener, getElementUUID, n, tagr, _fn, _i, _len, _ref,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  EventEmitter = (function() {

    EventEmitter.name = 'EventEmitter';

    function EventEmitter() {}

    EventEmitter.prototype.listeners = function(type) {
      if (this.hasOwnProperty.call((this._events != null ? this._events : this._events = {}), type)) {
        return this._events[type];
      } else {
        return this._events[type] = [];
      }
    };

    EventEmitter.prototype.on = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.addListener.apply(this, args);
    };

    EventEmitter.prototype.once = function(type, f) {
      var g;
      return this.on(type, g = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        f.apply(this, args);
        return this.removeListener(type, g);
      });
    };

    EventEmitter.prototype.addListener = function(type, f) {
      if ((this.listeners(type).push(f)) > this._maxListeners && this._maxListeners !== 0) {
        if (typeof console !== "undefined" && console !== null) {
          console.warn("Possible EventEmitter memory leak detected. " + this._events[type].length + " listeners added. Use emitter.setMaxListeners() to increase limit.");
        }
      }
      this.emit("newListener", type, f);
      return this;
    };

    EventEmitter.prototype.removeListener = function(type, f) {
      var i;
      if ((i = this.listeners(type).indexOf(f)) !== -1) {
        this.listeners(type).splice(i, 1);
      }
      return this;
    };

    EventEmitter.prototype.removeAllListeners = function(type) {
      var k, v, _ref;
      _ref = this._events || {};
      for (k in _ref) {
        v = _ref[k];
        if (!(type != null) || type === k) {
          v.splice(0, v.length);
        }
      }
      return this;
    };

    EventEmitter.prototype.emit = function() {
      var args, f, type, _i, _len, _ref;
      type = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _ref = this.listeners(type);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        f.apply(this, args);
      }
      return this.listeners(type).length > 0;
    };

    EventEmitter.prototype._maxListeners = 10;

    EventEmitter.prototype.setMaxListeners = function(_maxListeners) {
      this._maxListeners = _maxListeners;
    };

    return EventEmitter;

  })();

  addDomReadyListener = (function() {
    var flush, fn, fns, loaded;
    loaded = /^loade|c/.test(document.readyState);
    fns = [];
    flush = function(f) {
      var _results;
      loaded = true;
      _results = [];
      while (f = fns.shift()) {
        _results.push(f());
      }
      return _results;
    };
    if (document.documentElement.doScroll) {
      document.attachEvent("onreadystatechange", fn = function() {
        if (/^c/.test(document.readyState)) {
          document.detachEvent("onreadystatechange", fn);
          return flush();
        }
      });
      return function(fn) {
        if (self !== top) {
          if (loaded) {
            return fn();
          } else {
            return fns.push(fn);
          }
        } else {
          return (function() {
            try {
              testEl.doScroll("left");
            } catch (e) {
              return setTimeout((function() {
                return ready(fn);
              }), 50);
            }
            return fn();
          })();
        }
      };
    }
    if (document.addEventListener != null) {
      document.addEventListener("DOMContentLoaded", fn = function() {
        document.removeEventListener("DOMContentLoaded", fn, false);
        return flush();
      }, false);
      return function(fn) {
        if (loaded) {
          return fn();
        } else {
          return fns.push(fn);
        }
      };
    }
  })();

  this.Stylesheet = Stylesheet = function(media) {
    var s;
    if (media == null) {
      media = 'all';
    }
    s = document.createElement('style');
    s.type = 'text/css';
    s.media = media;
    document.getElementsByTagName('head')[0].appendChild(s);
    return s;
  };

  this.Script = Script = function() {
    var s;
    s = document.createElement('script');
    s.src = 'about:blank';
    document.getElementsByTagName('head')[0].appendChild(s);
    return s;
  };

  getElementUUID = (function() {
    var uuid;
    uuid = 0;
    return function(elem) {
      var _ref;
      return (_ref = elem.uniqueId) != null ? _ref : (elem.uniqueId = uuid++);
    };
  })();

  DomMap = (function() {
    var isEmptyObject;

    DomMap.name = 'DomMap';

    isEmptyObject = function(obj) {
      var key;
      for (key in obj) {
        return false;
        return true;
      }
    };

    function DomMap() {
      this.cache = {};
    }

    DomMap.prototype.set = function(elem, name, value) {
      var _base, _name, _ref;
      return ((_ref = (_base = this.cache)[_name = getElementUUID(elem)]) != null ? _ref : _base[_name] = {})[name] = value;
    };

    DomMap.prototype.get = function(elem, name) {
      var data;
      if ((data = this.cache[getElementUUID(elem)]) != null) {
        return data[name];
      } else {
        return null;
      }
    };

    DomMap.prototype.remove = function(elem, name) {
      var obj;
      if (obj = this.cache[getElementUUID(elem)]) {
        delete obj[name];
        if (isEmptyObject(obj)) {
          delete this.cache[getElementUUID(elem)];
        }
      }
      return null;
    };

    DomMap.prototype.clean = function(elem) {
      return delete this.cache[getElementUUID(elem)];
    };

    return DomMap;

  })();

  this.tagr = tagr = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return tagr.create.apply(tagr, args);
  };

  tagr.IGNORE_ATTRS = ['data-tagr'];

  tagr.create = function(tag, attrs) {
    var e, k, v;
    if (attrs == null) {
      attrs = {};
    }
    e = document.createElement(tag);
    for (k in attrs) {
      v = attrs[k];
      e.setAttribute(k, v);
    }
    return new Tagr(e);
  };

  tagr.parse = function(str) {
    var arg, args, attrs, e, tag;
    if (typeof str === 'string') {
      return str;
    }
    tag = str[0], attrs = str[1], args = 3 <= str.length ? __slice.call(str, 2) : [];
    e = tagr.create(tag, attrs);
    e.append.apply(e, (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        _results.push(tagr.parse(arg));
      }
      return _results;
    })());
    return e;
  };

  tagr.ready = addDomReadyListener;

  tagr._map = new DomMap();

  tagr.getContext = function(node) {
    var obj;
    if (node.nodeType !== 1) {
      throw new Error('Cannot create Tagr context from non-element');
    }
    if ((obj = tagr._map.get(node, 'tagr')) == null) {
      tagr._map.set(node, 'tagr', (obj = new Tagr(node)));
    }
    return obj;
  };

  tagr.getWrapper = function(node) {
    var obj;
    if (node.nodeType !== 1) {
      throw new Error('Cannot create Tagr context of non-element');
    }
    if ((obj = tagr._map.get(node, 'tagr')) == null) {
      throw new Error('No Tagr wrapper exists for this element.');
    }
    return obj;
  };

  tagr.writeContext = function(tag, attrs) {
    var list;
    if (tag == null) {
      tag = 'div';
    }
    if (attrs == null) {
      attrs = {};
    }
    document.write("<" + tag + "></" + tag + ">");
    list = document.getElementsByTagName('*');
    return tagr.getContext(list[list.length - 1]).setAttrs(attrs);
  };

  Tagr = (function(_super) {
    var getDomProperty;

    __extends(Tagr, _super);

    Tagr.name = 'Tagr';

    function Tagr(node, parent) {
      var attr, c, i, k, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.node = node;
      this.parent = parent;
      this.tag = this.node.nodeName.toLowerCase();
      this.attrs = {};
      _ref = this.node.attributes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        if (__indexOf.call(tagr.IGNORE_ATTRS, attr) < 0) {
          this.attrs[attr.name] = attr.value;
        }
      }
      this.classes = this.node.className.match(/\S+/g) || [];
      this.style = {};
      _ref1 = this.node.style;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        k = _ref1[_j];
        this.style[k] = this.node.style[k];
      }
      this.length = this.node.childNodes.length;
      _ref2 = this.node.childNodes;
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        c = _ref2[i];
        this[i] = (c.nodeType === 1 ? new Tagr(c, this) : c.nodeValue);
      }
    }

    Tagr.prototype._attach = function(parent) {
      this.parent = parent;
      return tagr._map.set(this.node, 'tagr', this);
    };

    Tagr.prototype._detach = function() {
      this.parent = null;
      return tagr._map.remove(this.node, 'tagr');
    };

    Tagr.prototype._ensureAttrUuid = function() {
      if (!this.node.hasAttribute('data-tagr')) {
        this.node.setAttribute('data-tagr', getElementUUID(this.node));
      }
      return this.node.getAttribute('data-tagr');
    };

    Tagr.prototype.splice = function() {
      var add, c, del, i, j, n, ret, right, _i, _j, _k, _len, _ref, _ref1, _ref2;
      i = arguments[0], del = arguments[1], add = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (i < 0 || isNaN(i)) {
        throw 'Invalid index';
      }
      if (del) {
        ret = (function() {
          var _i, _results;
          _results = [];
          for (j = _i = 0; 0 <= del ? _i < del : _i > del; j = 0 <= del ? ++_i : --_i) {
            c = this[i + j];
            this.node.removeChild(this.node.childNodes[i]);
            if (typeof c === 'object') {
              c._detach();
            }
            delete this[i + j];
            _results.push(c);
          }
          return _results;
        }).call(this);
      }
      if (del > add.length) {
        for (j = _i = _ref = i + del, _ref1 = this.length; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; j = _ref <= _ref1 ? ++_i : --_i) {
          this[j - del] = this[j];
        }
      }
      if (add.length > del) {
        for (j = _j = _ref2 = this.length + add.length - 1; _ref2 <= i ? _j < i : _j > i; j = _ref2 <= i ? ++_j : --_j) {
          this[j] = this[j - add.length];
        }
      }
      if (add.length) {
        right = this.node.childNodes[i];
        for (j = _k = 0, _len = add.length; _k < _len; j = ++_k) {
          c = add[j];
          if (typeof c === 'object' && (c != null ? c.constructor : void 0) === Array) {
            c = tagr.parse(c);
            n = c.node;
          } else if (typeof c === 'string') {
            n = document.createTextNode(c);
          } else {
            n = c.node;
          }
          if (n.parentNode) {
            throw new Error('Must remove element before appending elsewhere.');
          }
          this.node.insertBefore(n, right);
          if (typeof c === 'object') {
            c._attach(this);
          }
          this[i + j] = c;
        }
      }
      this.length += (-del) + add.length;
      return ret;
    };

    Tagr.prototype.append = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.splice.apply(this, [this.length, 0].concat(__slice.call(args)));
      return this;
    };

    Tagr.prototype.prepend = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.splice.apply(this, [0, 0].concat(__slice.call(args)));
      return this;
    };

    Tagr.prototype.remove = function(i) {
      this.splice(i, 1);
      return this;
    };

    Tagr.prototype.insert = function(i, e) {
      this.splice(i, 0, e);
      return this;
    };

    Tagr.prototype.empty = function() {
      this.splice(0, this.length);
      return this;
    };

    Tagr.prototype.appendSelf = function(e) {
      e.append(this);
      return this;
    };

    Tagr.prototype.prependSelf = function(e) {
      e.prepend(this);
      return this;
    };

    Tagr.prototype.removeSelf = function() {
      this.parent.remove(this.parent.indexOf(this));
      return this;
    };

    Tagr.prototype.insertSelf = function(parent, i) {
      parent.insert(i, this);
      return this;
    };

    Tagr.prototype.indexOfSelf = function() {
      return this.parent.indexOf(this);
    };

    Tagr.prototype.select = function(match) {
      return new TagrList(this, match);
    };

    Tagr.prototype.find = function(match) {
      return this.select(match).find();
    };

    getDomProperty = (function() {
      var props;
      props = {
        'class': 'className'
      };
      return function(name) {
        var _ref;
        return (_ref = props[name]) != null ? _ref : name;
      };
    })();

    Tagr.prototype.setAttr = function(name, v) {
      if (name === 'class') {
        this.classes = v.match(/\S+/g) || [];
      }
      this.node[getDomProperty(name)] = this.attrs[name] = v;
      return this;
    };

    Tagr.prototype.setAttrs = function(map) {
      var k, v;
      for (k in map) {
        v = map[k];
        this.setAttr(k, v);
      }
      return this;
    };

    Tagr.prototype.setClass = function(name, toggle) {
      var c;
      if (toggle == null) {
        toggle = true;
      }
      if (toggle) {
        if (__indexOf.call(this.classes, name) < 0) {
          this.classes = this.classes.concat([name]);
        }
        this.setAttr('class', this.classes.join(' '));
      } else {
        this.classes = (function() {
          var _i, _len, _ref, _results;
          _ref = this.classes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            if (c !== name) {
              _results.push(c);
            }
          }
          return _results;
        }).call(this);
        this.setAttr('class', this.classes.join(' '));
      }
      return this;
    };

    Tagr.prototype.setClasses = function(map) {
      var k, v;
      for (k in map) {
        v = map[k];
        this.setClass(k, v);
      }
      return this;
    };

    Tagr.prototype.setStyle = function(k, v) {
      if (!v) {
        throw new Exception('setStyle must be called with a value.');
      }
      this.style[k] = this.node.style[k] = v;
      return this;
    };

    Tagr.prototype.setStyles = function(map) {
      var k, v;
      for (k in map) {
        v = map[k];
        this.setStyle(k, v);
      }
      return this;
    };

    Tagr.prototype.addListener = function(type, f) {
      var _this = this;
      this.node.addEventListener(type, (function(e) {
        return _this.emit(type, e);
      }), false);
      return Tagr.__super__.addListener.call(this, type, f);
    };

    Tagr.prototype.toJSON = function() {
      var x;
      return [this.tag, this.attrs].concat(__slice.call((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = this.length; _i < _len; _i++) {
            x = this[_i];
            _results.push(typeof x === 'string' ? x : x.toJSON());
          }
          return _results;
        }).call(this)));
    };

    Tagr.prototype.loadHTML = function(html) {
      this.empty();
      this.node.innerHTML = html;
      return this.constructor(this.node, this.parent);
    };

    Tagr.prototype.toHTML = function() {
      return this.node.innerHTML;
    };

    Tagr.prototype.useWhitespace = function() {
      this.setStyle('white-space', 'pre');
      this.setStyle('word-wrap', 'break-word');
      this.setStyle('white-space', 'pre-wrap');
      this.setStyle('white-space', '-moz-pre-wrap');
      this.setStyle('white-space', '-pre-wrap');
      return this.setStyle('white-space', '-o-pre-wrap');
    };

    Tagr.prototype.setSelectable = function() {
      return this.setStyle;
    };

    return Tagr;

  })(EventEmitter);

  _ref = ['forEach', 'slice', 'map', 'indexOf'];
  _fn = function(n) {
    return Tagr.prototype[n] = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return Array.prototype[n].apply(this, args);
    };
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    n = _ref[_i];
    _fn(n);
  }

  TagrList = (function(_super) {
    var getStylesheet, sCache;

    __extends(TagrList, _super);

    TagrList.name = 'TagrList';

    sCache = {};

    getStylesheet = function(media) {
      var s;
      if (media == null) {
        media = 'all';
      }
      if (sCache[media] != null) {
        return sCache[media];
      }
      s = new Stylesheet(media);
      return sCache[media] = s.sheet || s.styleSheet;
    };

    function TagrList(ctx, match) {
      this.ctx = ctx;
      this.match = match;
    }

    TagrList.prototype.find = function() {
      var el, _j, _len1, _ref1, _results;
      _ref1 = Sizzle(match, this.ctx.node);
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        el = _ref1[_j];
        _results.push(new Tagr(el));
      }
      return _results;
    };

    TagrList.prototype.addListener = function(type, f) {
      var _this = this;
      this.ctx.node.addEventListener(type, (function(e) {
        var matches, _results;
        matches = Sizzle("" + _this.match, _this.ctx.node);
        n = e.target;
        _results = [];
        while (n !== _this.ctx.node && n) {
          if (__indexOf.call(matches, n) >= 0) {
            f.call(tagr.getWrapper(n), e);
          }
          _results.push(n = n.parentNode);
        }
        return _results;
      }), false);
      return TagrList.__super__.addListener.call(this, type, f);
    };

    TagrList.prototype.setStyle = function(k, v) {
      var s, selector;
      if (!v) {
        throw new Exception('setStyle must be called with a value.');
      }
      selector = "[data-tagr='" + (this.ctx._ensureAttrUuid()) + "'] " + this.match;
      s = getStylesheet();
      s.insertRule("" + selector + " { " + k + ": " + v + " }", s.cssRules.length);
      return this;
    };

    TagrList.prototype.setStyles = function(map) {
      var k, v;
      for (k in map) {
        v = map[k];
        this.setStyle(k, v);
      }
      return this;
    };

    return TagrList;

  })(EventEmitter);

}).call(this);
