// Generated by CoffeeScript 1.3.1

/**
* @license Tagr, HTML manipulation for webapps. MIT Licensed.
*/


/*

DOM TODO:
	compareDocumentPosition
	offsets, custom JSON serialization
	data attributes, custom data, custom attributes
	browser testing. ie6 leak prevention
	normalize events
	verify 'input' value always works

USAGE TODO:
	create usable widget patterns
	integrate with Backbone, or replicate model at least
	comment errything
	server/browser integration
	contenteditable
	server-side version
	writeContext should obviously take children (cool)

CONTEXTS:
	should context objects be a subclass?
	context-interchangeable positions-can mix contexts?
	tagr.view is properties of context?
*/


(function() {
  var ArrayHash, DomMap, ElementAnchor, EventEmitter, HTML_DOM_PROPS, SIMPLE_SELECTOR_CHUNKER, SIMPLE_SELECTOR_MATCH, Script, Stylesheet, TagrElement, TextAnchor, addDomReadyListener, convertAnchor, findBySelector, fromCamelCase, getComputedStyle, getElementUniqueId, keyListable, mappable, n, parseSimpleSelector, spliceObject, tagr, toCamelCase, valueListable, _fn, _i, _len, _ref,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  EventEmitter = (function() {

    EventEmitter.name = 'EventEmitter';

    function EventEmitter() {}

    EventEmitter.prototype["listeners"] = function(type) {
      if (this.hasOwnProperty.call((this._events != null ? this._events : this._events = {}), type)) {
        return this._events[type];
      } else {
        return this._events[type] = [];
      }
    };

    EventEmitter.prototype["on"] = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this["addListener"].apply(this, args);
    };

    EventEmitter.prototype["once"] = function(type, f) {
      var g;
      return this["on"](type, g = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        f.apply(this, args);
        return this["removeListener"](type, g);
      });
    };

    EventEmitter.prototype["addListener"] = function(type, f) {
      if ((this["listeners"](type).push(f)) > this._maxListeners && this._maxListeners !== 0) {
        if (typeof console !== "undefined" && console !== null) {
          console.warn("Possible EventEmitter memory leak detected. " + this._events[type].length + " listeners added. Use emitter.setMaxListeners() to increase limit.");
        }
      }
      this["emit"]("newListener", type, f);
      return this;
    };

    EventEmitter.prototype["removeListener"] = function(type, f) {
      var i;
      if ((i = this["listeners"](type).indexOf(f)) !== -1) {
        this["listeners"](type).splice(i, 1);
      }
      return this;
    };

    EventEmitter.prototype["removeAllListeners"] = function(type) {
      var k, v, _ref;
      _ref = this._events || {};
      for (k in _ref) {
        v = _ref[k];
        if (!(type != null) || type === k) {
          v.splice(0, v.length);
        }
      }
      return this;
    };

    EventEmitter.prototype["emit"] = function() {
      var args, f, type, _i, _len, _ref;
      type = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _ref = this["listeners"](type);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        f.apply(this, args);
      }
      return this["listeners"](type).length > 0;
    };

    EventEmitter.prototype._maxListeners = 10;

    EventEmitter.prototype["setMaxListeners"] = function(_maxListeners) {
      this._maxListeners = _maxListeners;
    };

    return EventEmitter;

  })();

  mappable = function(fn) {
    return function(k, v) {
      var mk, mv;
      if (!(arguments.length > 1 || typeof k !== 'object')) {
        for (mk in k) {
          mv = k[mk];
          fn.call(this, mk, mv);
        }
        return this;
      }
      return fn.call(this, k, v);
    };
  };

  keyListable = function(fn) {
    return function(k, v) {
      var mk, _i, _len;
      if (typeof k === 'object' && ((k != null ? k.length : void 0) != null)) {
        for (_i = 0, _len = k.length; _i < _len; _i++) {
          mk = k[_i];
          fn.call(this, mk, v);
        }
        return this;
      }
      return fn.call(this, k, v);
    };
  };

  valueListable = function(fn) {
    return function(k, v) {
      var mv, _i, _len;
      if (typeof v === 'object' && ((v != null ? v.length : void 0) != null)) {
        for (_i = 0, _len = v.length; _i < _len; _i++) {
          mv = v[_i];
          fn.call(this, k, mv);
        }
        return this;
      }
      return fn.call(this, k, v);
    };
  };

  ArrayHash = (function() {

    ArrayHash.name = 'ArrayHash';

    function ArrayHash(chain, handlers) {
      var arr, hash, proxy;
      if (handlers == null) {
        handlers = {};
      }
      hash = {};
      arr = this;
      arr.length = 0;
      proxy = function(chain, f) {
        return function() {
          return f.apply(chain, arguments);
        };
      };
      this["get"] = proxy(chain, function(k) {
        if ((handlers != null ? handlers.get : void 0) != null) {
          return handlers.get(k);
        } else {
          return hash['@' + k];
        }
      });
      this["set"] = proxy(chain, mappable(keyListable(valueListable(function(k, v) {
        if (!Object.prototype.hasOwnProperty.call(hash, '@' + k)) {
          arr[arr.length++] = k;
        }
        if (handlers != null) {
          if (typeof handlers.set === "function") {
            handlers.set(k, v);
          }
        }
        hash['@' + k] = v;
        return this;
      }))));
      this["remove"] = proxy(chain, function(k) {
        var i, j, tk, _i, _j, _len, _ref;
        if (Object.prototype.hasOwnProperty.call(hash, '@' + k)) {
          for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
            tk = this[i];
            if (!(tk === k)) {
              continue;
            }
            for (j = _j = i, _ref = arr.length - 1; i <= _ref ? _j < _ref : _j > _ref; j = i <= _ref ? ++_j : --_j) {
              arr[j] = arr[j + 1];
            }
            break;
          }
          arr.length--;
          if (handlers != null) {
            if (typeof handlers.remove === "function") {
              handlers.remove(k);
            }
          }
          delete hash['@' + k];
        }
        return this;
      });
    }

    return ArrayHash;

  })();

  fromCamelCase = function(name) {
    return name.replace(/([A-Z])/g, "-$1").toLowerCase();
  };

  toCamelCase = function(name) {
    return name.toLowerCase().replace(/\-[a-z]/g, (function(s) {
      return s[1].toUpperCase();
    }));
  };

  spliceObject = function() {
    var add, c, del, i, j, obj, ret, _i, _j, _k, _l, _len, _ref, _ref1, _ref2;
    obj = arguments[0], i = arguments[1], del = arguments[2], add = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    if (i < 0 || isNaN(i)) {
      throw 'Invalid index';
    }
    if (del) {
      ret = [];
      for (j = _i = 0; 0 <= del ? _i < del : _i > del; j = 0 <= del ? ++_i : --_i) {
        ret.push(obj[i + j]);
        delete obj[i + j];
      }
    }
    if (del > add.length) {
      for (j = _j = _ref = i + del, _ref1 = obj.length; _ref <= _ref1 ? _j < _ref1 : _j > _ref1; j = _ref <= _ref1 ? ++_j : --_j) {
        obj[j - del] = obj[j];
      }
    } else if (add.length > del) {
      for (j = _k = _ref2 = obj.length + add.length - 1; _ref2 <= i ? _k < i : _k > i; j = _ref2 <= i ? ++_k : --_k) {
        obj[j] = obj[j - add.length];
      }
    }
    if (add.length) {
      for (j = _l = 0, _len = add.length; _l < _len; j = ++_l) {
        c = add[j];
        obj[i + j] = c;
      }
    }
    obj.length += (-del) + add.length;
    return ret;
  };

  this['Stylesheet'] = Stylesheet = function(media) {
    var s;
    if (media == null) {
      media = 'all';
    }
    s = document.createElement('style');
    s.type = 'text/css';
    s.media = media;
    return document.getElementsByTagName('head')[0].appendChild(s);
  };

  this['Script'] = Script = function() {
    var s;
    s = document.createElement('script');
    s.src = 'about:blank';
    return document.getElementsByTagName('head')[0].appendChild(s);
  };

  HTML_DOM_PROPS = {
    "for": "htmlFor",
    accesskey: "accessKey",
    codebase: "codeBase",
    frameborder: "frameBorder",
    framespacing: "frameSpacing",
    nowrap: "noWrap",
    maxlength: "maxLength",
    "class": "className",
    readonly: "readOnly",
    longdesc: "longDesc",
    tabindex: "tabIndex",
    rowspan: "rowSpan",
    colspan: "colSpan",
    enctype: "encType",
    ismap: "isMap",
    usemap: "useMap",
    cellpadding: "cellPadding",
    cellspacing: "cellSpacing"
  };

  addDomReadyListener = (function() {
    var flush, fn, fns, loaded;
    loaded = /^loade|c/.test(document.readyState);
    fns = [];
    flush = function(f) {
      var _results;
      loaded = true;
      _results = [];
      while (f = fns.shift()) {
        _results.push(f());
      }
      return _results;
    };
    if (document.documentElement.doScroll) {
      document.attachEvent("onreadystatechange", fn = function() {
        if (/^c/.test(document.readyState)) {
          document.detachEvent("onreadystatechange", fn);
          return flush();
        }
      });
      return function(fn) {
        if (self !== top) {
          if (loaded) {
            return fn();
          } else {
            return fns.push(fn);
          }
        } else {
          return (function() {
            try {
              testEl.doScroll("left");
            } catch (e) {
              return setTimeout((function() {
                return ready(fn);
              }), 50);
            }
            return fn();
          })();
        }
      };
    }
    if (document.addEventListener != null) {
      document.addEventListener("DOMContentLoaded", fn = function() {
        document.removeEventListener("DOMContentLoaded", fn, false);
        return flush();
      }, false);
      return function(fn) {
        if (loaded) {
          return fn();
        } else {
          return fns.push(fn);
        }
      };
    }
  })();

  getComputedStyle = function(n, name) {
    var computedStyle, left, rsLeft, val, _ref, _ref1, _ref2;
    if (window.getComputedStyle) {
      computedStyle = n.ownerDocument.defaultView.getComputedStyle(n, null);
      val = computedStyle != null ? computedStyle.getPropertyValue(name) : void 0;
      return (name === "opacity" && val === "" ? "1" : val);
    } else if (n.currentStyle) {
      val = (_ref = n.currentStyle[name]) != null ? _ref : n.currentStyle[toCamelCase(name)];
      if (!/^\d+(?:px)?$/i.test(ret) && /^\d/.test(ret)) {
        _ref1 = [n.style.left, n.runtimeStyle.left], left = _ref1[0], rsLeft = _ref1[1];
        n.runtimeStyle.left = n.currentStyle.left;
        n.style.left = (name === "font-size" ? "1em" : val || 0);
        val = n.style.pixelLeft + "px";
        _ref2 = [left, rsLeft], n.style.left = _ref2[0], n.runtimeStyle.left = _ref2[1];
      }
      return val;
    }
  };

  findBySelector = (function() {
    var browser;
    browser = (function() {
      var sheet;
      if (document.querySelector != null) {
        return function(root, selector) {
          return root.querySelectorAll(selector);
        };
      } else if (document.documentElement.currentStyle != null) {
        sheet = new Stylesheet();
        return function(root, selector) {
          var res, tag, x, _ref;
          tag = (_ref = selector.match(SIMPLE_SELECTOR_MATCH)) != null ? _ref[1] : void 0;
          sheet.addRule(selector, 'foo:bar');
          res = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = (tag ? root.tags(tag) : root.all);
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              x = _ref1[_i];
              if (x.currentStyle.foo === 'bar') {
                _results.push(x);
              }
            }
            return _results;
          })();
          sheet.removeRule(0);
          return res;
        };
      }
    })();
    return function(root, selector) {
      if (typeof Sizzle !== 'undefined') {
        return Sizzle(selector, root);
      } else {
        return browser(root, selector);
      }
    };
  })();

  getElementUniqueId = (function() {
    var uuid;
    uuid = 0;
    return function(elem) {
      var _ref;
      return (_ref = elem.uniqueId) != null ? _ref : (elem.uniqueId = uuid++);
    };
  })();

  DomMap = (function() {

    DomMap.name = 'DomMap';

    function DomMap() {
      this.cache = {};
    }

    DomMap.prototype.set = function(elem, value) {
      return this.cache[getElementUniqueId(elem)] = value;
    };

    DomMap.prototype.get = function(elem) {
      return this.cache[getElementUniqueId(elem)];
    };

    DomMap.prototype.remove = function(elem) {
      return delete this.cache[getElementUniqueId(elem)];
    };

    return DomMap;

  })();

  SIMPLE_SELECTOR_MATCH = /(?:^|\s+)([^.#\[\]:\s]*)(\S*)\s*$/;

  SIMPLE_SELECTOR_CHUNKER = /([:#.]+)([^:#.]+)/g;

  parseSimpleSelector = function(selector) {
    var attr, match, ret, _i, _len, _ref;
    if (!(match = selector.match(SIMPLE_SELECTOR_MATCH))) {
      return;
    }
    ret = {
      tag: match[1] || 'div',
      classes: [],
      id: null
    };
    _ref = match[2].match(SIMPLE_SELECTOR_CHUNKER) || [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      attr = _ref[_i];
      switch (attr[0]) {
        case '#':
          ret.id = attr.substr(1);
          break;
        case '.':
          ret.classes.push(attr.substr(1));
      }
    }
    return ret;
  };

  this['tagr'] = tagr = function(simple, attrs) {
    var e, sel;
    if (attrs == null) {
      attrs = {};
    }
    sel = parseSimpleSelector(simple || '');
    e = document.createElement(sel.tag);
    if (sel.classes.length) {
      e.className = sel.classes.join(' ');
    }
    if (sel.id) {
      e.id = sel.id;
    }
    return new TagrElement(e).set(attrs);
  };

  tagr.IGNORE_ATTRS = ['data-tagr'];

  tagr['parse'] = function(str) {
    var arg, args, attrs, simple, _ref;
    if (typeof str === 'string') {
      return str;
    }
    simple = str[0], attrs = str[1], args = 3 <= str.length ? __slice.call(str, 2) : [];
    return (_ref = tagr(simple, attrs)).append.apply(_ref, (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        _results.push(tagr.parse(arg));
      }
      return _results;
    })());
  };

  tagr['ready'] = addDomReadyListener;

  tagr._map = new DomMap();

  tagr._getWrapper = function(node, initialize) {
    var obj;
    if (initialize == null) {
      initialize = false;
    }
    if (node.nodeType !== 1) {
      throw new Error('Cannot create Tagr context of non-element');
    }
    if ((obj = tagr._map.get(node)) == null) {
      if (!initialize) {
        throw new Error('No Tagr wrapper exists for this element.');
      }
      tagr._map.set(node, (obj = new TagrElement(node)));
    }
    return obj;
  };

  tagr['getContext'] = function(node) {
    return tagr._getWrapper(node, true);
  };

  tagr['writeContext'] = function(tag, props) {
    var list;
    if (tag == null) {
      tag = 'div';
    }
    if (props == null) {
      props = {};
    }
    document.write("<" + tag + "></" + tag + ">");
    list = document.getElementsByTagName(tag);
    return tagr["getContext"](list[list.length - 1])["set"](props);
  };

  tagr['TagrElement'] = TagrElement = (function(_super) {

    __extends(TagrElement, _super);

    TagrElement.name = 'TagrElement';

    function TagrElement(_node, parent) {
      var c, i, name, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      this._node = _node;
      this.parent = parent;
      this["tag"] = this._node.nodeName.toLowerCase();
      this["classes"] = new ArrayHash(this, {
        set: function(k, v) {
          var c;
          if (v == null) {
            v = true;
          }
          return _this._node.className = "" + (((function() {
            var _i, _len, _ref, _results;
            _ref = this["classes"];
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              c = _ref[_i];
              if (c !== k) {
                _results.push(c);
              }
            }
            return _results;
          }).call(_this)).join('')) + " " + (v ? k : '') + " " + _this._uuidClass;
        },
        get: function(k) {
          return !!_this._node.className.match(new RegExp("\\b" + k + "\\b"));
        },
        remove: function(k) {
          var c;
          return _this._node.className = ((function() {
            var _i, _len, _ref, _results;
            _ref = this["classes"];
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              c = _ref[_i];
              if (c !== k) {
                _results.push(c);
              }
            }
            return _results;
          }).call(_this)).join('');
        }
      });
      _ref = this._node.className.match(/\S+/g) || [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        this["classes"].set(name);
      }
      this["style"] = new ArrayHash(this, {
        set: function(k, v) {
          return _this._node.style[toCamelCase(k)] = v;
        },
        get: function(k) {
          return _this._node.style[toCamelCase(k)];
        },
        remove: function(k) {
          return delete _this._node.style[toCamelCase(k)];
        }
      });
      this.length = this._node.childNodes.length;
      _ref1 = this._node.childNodes;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        c = _ref1[i];
        this[i] = (c.nodeType === 1 ? new TagrElement(c, this) : c._nodeValue);
      }
    }

    TagrElement.prototype._attach = function(parent) {
      this.parent = parent;
      return tagr._map.set(this._node, this);
    };

    TagrElement.prototype._detach = function() {
      delete this.parent;
      return tagr._map.remove(this._node);
    };

    TagrElement.prototype._ensureUuidClass = function() {
      if (!(this._uuidClass != null)) {
        this._node.className += ' ' + (this._uuidClass = 'tagr-' + getElementUniqueId(this._node));
      }
      return this._uuidClass;
    };

    TagrElement.prototype["get"] = function(k) {
      var _ref;
      return this._node[(_ref = HTML_DOM_PROPS[k]) != null ? _ref : k];
    };

    TagrElement.prototype["set"] = mappable(function(k, v) {
      var _ref;
      this["emit"]('change:' + k, v);
      this._node[(_ref = HTML_DOM_PROPS[k]) != null ? _ref : k] = v;
      return this;
    });

    TagrElement.prototype["remove"] = function(k) {
      this._node.removeAttribute(k);
      return this;
    };

    TagrElement.prototype["addListener"] = function(type, f) {
      var _this = this;
      if (this._node.addEventListener) {
        this._node.addEventListener(type, (function(e) {
          return _this["emit"](type, e);
        }), false);
      } else if (this._node.attachEvent) {
        this._node.attachEvent('on' + type((function() {
          return _this["emit"](type, window.event);
        })));
      }
      return TagrElement.__super__["addListener"].call(this, type, f);
    };

    TagrElement.prototype["splice"] = function() {
      var add, del, i, j, n, obj, right, _i, _j, _len;
      i = arguments[0], del = arguments[1], add = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      for (j = _i = 0; 0 <= del ? _i < del : _i > del; j = 0 <= del ? ++_i : --_i) {
        this._node.removeChild(this._node.childNodes[i]);
        if (typeof this[i + j] === 'object') {
          this[i + j]._detach();
        }
      }
      right = this._node.childNodes[i];
      for (j = _j = 0, _len = add.length; _j < _len; j = ++_j) {
        obj = add[j];
        if (typeof obj === 'object') {
          if (obj.constructor === Array) {
            obj = add[j] = tagr["parse"](obj);
          }
          n = obj._node;
        } else {
          n = document.createTextNode(obj);
        }
        if (n.parentNode) {
          throw new Error('Must remove element before appending elsewhere.');
        }
        this._node.insertBefore(n, right);
        if (typeof obj === 'object') {
          obj._attach(this);
        }
      }
      return spliceObject.apply(null, [this, i, del].concat(__slice.call(add)));
    };

    TagrElement.prototype["append"] = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this["splice"].apply(this, [this.length, 0].concat(__slice.call(args)));
      return this;
    };

    TagrElement.prototype["prepend"] = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this["splice"].apply(this, [0, 0].concat(__slice.call(args)));
      return this;
    };

    TagrElement.prototype["remove"] = function(i) {
      this["splice"](i, 1);
      return this;
    };

    TagrElement.prototype["insert"] = function() {
      var args, i;
      i = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this["splice"].apply(this, [i, 0].concat(__slice.call(args)));
      return this;
    };

    TagrElement.prototype["empty"] = function() {
      this["splice"](0, this.length);
      return this;
    };

    TagrElement.prototype["appendSelf"] = function(e) {
      e["append"](this);
      return this;
    };

    TagrElement.prototype["prependSelf"] = function(e) {
      e["prepend"](this);
      return this;
    };

    TagrElement.prototype["removeSelf"] = function() {
      this["parent"]["remove"](this["index"]());
      return this;
    };

    TagrElement.prototype["insertSelf"] = function(parent, i) {
      parent["insert"](i, this);
      return this;
    };

    TagrElement.prototype["index"] = function() {
      return this["parent"].indexOf(this);
    };

    TagrElement.prototype["select"] = function(match) {
      return new tagr["TagrQuery"](this, match);
    };

    TagrElement.prototype["find"] = function(match) {
      return this["select"](match)["find"]();
    };

    TagrElement.prototype["toJSON"] = function() {
      var x;
      return [this.tag, this.attrs].concat(__slice.call((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = this.length; _i < _len; _i++) {
            x = this[_i];
            _results.push(typeof x === 'string' ? x : x.toJSON());
          }
          return _results;
        }).call(this)));
    };

    return TagrElement;

  })(EventEmitter);

  _ref = ['forEach', 'slice', 'map', 'indexOf'];
  _fn = function(n) {
    return TagrElement.prototype[n] = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return Array.prototype[n].apply(this, args);
    };
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    n = _ref[_i];
    _fn(n);
  }

  tagr['TagrQuery'] = (function() {
    var TagrQuery, getStylesheet, sCache;
    sCache = {};
    getStylesheet = function(media) {
      var s;
      if (media == null) {
        media = 'all';
      }
      if (sCache[media] != null) {
        return sCache[media];
      }
      s = new Stylesheet(media);
      return sCache[media] = s.sheet || s.styleSheet;
    };
    return TagrQuery = (function(_super) {

      __extends(TagrQuery, _super);

      TagrQuery.name = 'TagrQuery';

      function TagrQuery(ctx, selector) {
        var _this = this;
        this.ctx = ctx;
        this.selector = selector;
        this.style = new ArrayHash(this, {
          set: mappable(keyListable(valueListable(function(k, v) {
            var s;
            s = getStylesheet();
            s.insertRule("." + (_this.ctx._ensureUuidClass()) + " " + _this.selector + " { " + k + ": " + v + " }", s.cssRules.length);
            return _this;
          })))
        });
      }

      TagrQuery.prototype["addListener"] = function(type, f) {
        var _this = this;
        this.ctx._node.addEventListener(type, (function(e) {
          var matches, _results;
          matches = findBySelector(_this.ctx._node, _this.selector);
          n = e.target;
          _results = [];
          while (n !== _this.ctx._node && n) {
            if (__indexOf.call(matches, n) >= 0) {
              f.call(tagr._getWrapper(n), e);
            }
            _results.push(n = n.parentNode);
          }
          return _results;
        }), false);
        return TagrQuery.__super__["addListener"].call(this, type, f);
      };

      TagrQuery.prototype["find"] = function() {
        var el, _j, _len1, _ref1, _results;
        _ref1 = findBySelector(this.ctx._node, this.selector);
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          el = _ref1[_j];
          _results.push(tagr._getWrapper(el));
        }
        return _results;
      };

      return TagrQuery;

    })(EventEmitter);
  })();

  ElementAnchor = (function() {

    ElementAnchor.name = 'ElementAnchor';

    function ElementAnchor(par, i) {
      this.par = par;
      this.i = i;
    }

    ElementAnchor.prototype.toAnchor = function() {
      return [this.par._node, this.i];
    };

    return ElementAnchor;

  })();

  TextAnchor = (function() {

    TextAnchor.name = 'TextAnchor';

    function TextAnchor(par, child, i) {
      this.par = par;
      this.child = child;
      this.i = i;
    }

    TextAnchor.prototype.toAnchor = function() {
      return [this.par._node.childNodes[this.child], this.i];
    };

    return TextAnchor;

  })();

  convertAnchor = function(_arg) {
    var i, node, offset, t;
    node = _arg[0], offset = _arg[1];
    if (node.nodeType === 1) {
      if (!(t = tagr._getWrapper(node))) {
        return;
      }
      return new ElementAnchor(t, offset);
    } else {
      if (!(t = tagr._getWrapper(node.parentNode))) {
        return;
      }
      i = 0;
      n = node;
      while (n.previousSibling) {
        n = n.previousSibling;
        i++;
      }
      return new TextAnchor(el, i, offset);
    }
  };

  tagr['view'] = {
    "getBox": function(t, ctx) {
      var box, k, v, _ref1;
      box = t._node.getBoundingClientRect();
      if (ctx != null) {
        _ref1 = ctx._node.getBoundingClientRect();
        for (k in _ref1) {
          v = _ref1[k];
          box[k] -= v;
        }
      }
      return box;
    },
    "getStyle": function(t, name) {
      return getComputedStyle(t._node, name);
    },
    "selection": {
      "has": function() {
        return Selection.hasSelection(window);
      },
      "getOrigin": function() {
        return convertAnchor(Selection.getOrigin(window));
      },
      "getFocus": function() {
        return convertAnchor(Selection.getFocus(window));
      },
      "getStart": function() {
        return convertAnchor(Selection.getStart(window));
      },
      "getEnd": function() {
        return convertAnchor(Selection.getEnd(window));
      },
      "set": function(origin, focus) {
        return Selection.setSelection.apply(Selection, [window].concat(__slice.call(origin.toAnchor()), __slice.call(focus.toAnchor())));
      },
      "remove": function() {
        return Selection.clearSelection(window);
      }
    }
  };

  TagrElement.prototype['useWhitespace'] = function(toggle) {
    if (toggle == null) {
      toggle = true;
    }
    if (toggle) {
      return this.style.set({
        'white-space': ['pre', 'pre-wrap', '-moz-pre-wrap', '-pre-wrap', '-o-pre-wrap'],
        'word-wrap': 'break-word'
      });
    } else {
      return this.style.set(['white-space', 'word-wrap'], '');
    }
  };

  TagrElement.prototype['setSelectable'] = function(toggle) {
    if (toggle == null) {
      toggle = true;
    }
    return this.style.set(['-webkit-touch-callout', '-webkit-user-select', '-khtml-user-select', '-moz-user-select', '-ms-user-select', 'user-select'], toggle ? '' : 'none');
  };

}).call(this);
