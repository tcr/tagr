// Generated by CoffeeScript 1.3.1
(function() {
  var Cursor, button, content, ctx;

  ctx = tagr.writeContext().useWhitespace(true);

  content = tagr().appendSelf(ctx).append(['h1', {}, 'Teh heading'], ['p', {}, 'One paragraphs'], ['hr', {}], ['p', {}, 'Two paragraphs'], ['ul', {}, ['li', {}, 'List element 1'], ['li', {}, 'List element 2']], ['p', {}, 'Two paragraphs']).style.set({
    border: '1px solid red',
    padding: '10px'
  });

  Cursor = (function() {

    Cursor.name = 'Cursor';

    function Cursor() {}

    Cursor.prototype.toOpen = function(el) {
      var k, v, _ref;
      this.el = el;
      this.type = 'open';
      this.tag = this.el.tag;
      this.props = {};
      _ref = this.el.props;
      for (k in _ref) {
        v = _ref[k];
        this.props[k] = v;
      }
      return delete this.character;
    };

    Cursor.prototype.toClose = function(el) {
      this.el = el;
      this.type = 'close';
      delete this.tag;
      delete this.props;
      return delete this.character;
    };

    Cursor.prototype.toEmpty = function(el) {
      var k, v, _ref;
      this.el = el;
      this.type = 'empty';
      this.tag = this.el.tag;
      this.props = {};
      _ref = this.el.props;
      for (k in _ref) {
        v = _ref[k];
        this.props[k] = v;
      }
      return delete this.character;
    };

    Cursor.prototype.toCharacter = function(el, child, index) {
      this.el = el;
      this.child = child;
      this.index = index;
      this.type = 'character';
      delete this.tag;
      delete this.props;
      return this.character = this.el[this.child].charAt(this.index);
    };

    Cursor.prototype.next = function() {
      var next, par;
      switch (this.type) {
        case 'character':
          if (this.el[this.child].length > this.index + 1) {
            this.toCharacter(this.el, this.child, this.index + 1);
            return;
          }
          par = this.el;
          next = this.child + 1;
          break;
        case 'open':
          par = this.el;
          next = 0;
          break;
        case 'close':
          if (!this.el.parent) {
            this.toClose(this.el);
            this.type = 'end';
            return;
          }
          par = this.el.parent;
          next = this.el.index() + 1;
          break;
        case 'end':
          throw 'Cursor cannot exceed end of frame.';
      }
      if (typeof par[next] === 'string') {
        this.toCharacter(par, next, 0);
      } else if (par[next]) {
        this.toOpen(par[next]);
      } else {
        this.toClose(par);
      }
    };

    Cursor.prototype.prev = function() {
      var par, prev;
      switch (this.type) {
        case 'character':
          if (this.index > 0) {
            this.toCharacter(this.el, this.child, this.index - 1);
            return;
          }
          par = this.el;
          prev = this.child - 1;
          break;
        case 'open':
          if (!this.el.parent) {
            throw 'Cursor cannot preceed end of frame.';
          }
          par = this.el.parent;
          prev = this.el.index() - 1;
          break;
        case 'close':
        case 'end':
          par = this.el;
          prev = this.el.length - 1;
      }
      if (typeof par[prev] === 'string') {
        this.toCharacter(par, prev, par[prev].length - 1);
      } else if (par[prev]) {
        this.toClose(par[prev]);
      } else {
        this.toOpen(par);
      }
    };

    return Cursor;

  })();

  button = tagr('button').appendSelf(ctx).append('Log selection').on('click', function() {
    var c, _results;
    c = new Cursor;
    c.toOpen(content);
    while (c.type !== 'end') {
      console.log(c.type, c.tag, c.props, c.character);
      c.next();
    }
    c.toClose(content);
    _results = [];
    while (c.type !== 'open' || c.node !== this.el) {
      console.log(c.type, c.tag, c.props, c.character);
      _results.push(c.prev());
    }
    return _results;
  });

}).call(this);
